[↩ Get onto Radix](/../../tree/python-container)

# OAuth2 Proxy

It's time to authenticate users. Instead of implementing the details of OAuth 2.0 ourselves we will use a proxy container to do the work for us. The proxy will require users to log in and route subsequent traffic to our backend once authenticated.

The proxy will need Azure to redirect the user to itself so that it can redeem the authentication code for an `access-token`. The redirect url will need to be in the format `https://<auth-proxy-url>/oauth2/callback`

The source code for this component is hosted on
[github.com-oauth2-proxy](https://github.com/oauth2-proxy/oauth2-proxy)

## Azure Active Directory

The first piece of important information we will need from Azure is the `tenant-id` which is the AD (Active Directory) to use. You must have the permission to register applications in the tenant you wish to use. You can however create your own tenant and, in your app, permit multi-tenanted login to accept users from a tenant you do not control. Or you could manage the members yourself, using your tenant. We will not cover this case.

Before asking Azure to authenticate any users we need to give our application some identity. By registering our app under the tenant we have selected, we can get two pieces of information we'll need; a `client-id` for our app and a `client-secret` we can generate in the app's 'Certificates & secrets'. This makes sure permissions granted by users to our app can not be abused by other clients.

In addition to getting information from Azure, we also need to add some. What you need to give azure is your `redirect-url`. We add a platform of the web type under authentication settings, and enter the full url as an entry to the redirects list.

If the url does not match the requested redirect by our proxy, Azure will not cooperate.

## Radix Config

In the [radixconfig.yaml](/radixconfig.yaml), the server's port is no longer publicly exposed. All traffic is routed through the proxy, our new component. Its behavior is configured through setting environment variables.

- `OAUTH2_PROXY_PROVIDER`
  - This is the name of the protocol used with the identity provider, as the default value is `"google"` although our value will be `"oidc"`, not azure or microsoft.
- `OAUTH2_PROXY_OIDC_ISSUER_URL`
  - Specifies the identity provider end-point. In our case `"https://login.microsoftonline.com/<tenant-id>/v2.0"`.
- `OAUTH2_PROXY_CLIENT_ID`
  - Generated by Azure, uniquely identifies the client, which is your application.
- `OAUTH2_PROXY_REDIRECT_URL`
  - This must mirror the redirect url registered with Azure or it will refuse to authenticate.
- `OAUTH2_PROXY_SKIP_PROVIDER_BUTTON`
  - Default: false. We are only accepting Azure as identity provider in this example so we can skip any choice by setting this variable to true.
- `OAUTH2_PROXY_SCOPE`
  - Specifies what information and permissions is requested by the application from the user logging in. This should be kept at a functional minimum. Access tokens have a set lifespan. Adding `offline_access` permission will prolong the time the user can remain logged in. Read more at [auth0.com-openid-connect-scopes](https://auth0.com/docs/scopes/current/oidc-scopes). And for Azure specifically, [microsoft.com-azure-permissions-and-consent](https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent).
- `OAUTH2_PROXY_EMAIL_DOMAINS`
  - A string or list of e-mail domains that will be authenticated. A wildcard is used to accept any domain.
- `OAUTH2_PROXY_UPSTREAMS`
  - The url which authenticated requests are routed to. The internal cluster DNS will be able to resolve the name of the component to its IP, as it's used here.
- `OAUTH2_PROXY_HTTP_ADDRESS`
  - By default, the proxy listens to the network end-point `http://localhost:4180`, but since we need to reach it from outside the container, we need it to listen to any IP. An empty string accomplishes this. Setting this variable to `"http://:8000"` will change the listening port to 8000.
- `OAUTH2_PROXY_COOKIE_REFRESH`
  - Session data lifespan until it is refreshed.

There are many more options but this will be the minimal required for this working example. For more configuration options, see [github.io-oauth2-proxy-configuration](https://oauth2-proxy.github.io/oauth2-proxy/configuration)

## Secrets

Secrets will also be environment variables in the container, but their values must not be shown in the repository or configuration files. The values are stored in the cluster and will be writable from the Radix console web-page or cli after `radixconfig.yaml` is parsed. These are unrelated to github secrets.

- `OAUTH2_PROXY_CLIENT_SECRET`
  - Generated by Azure, used to authenticate the client (application) as opposed to the user
- `OAUTH2_PROXY_COOKIE_SECRET`
  - Encryption key for session storage. To generate a strong cookie secret, use `python -c 'import os,base64; print(base64.urlsafe_b64encode(os.urandom(16)).decode())'`

## Server

The [server](/server.py) requires no changes but since we should have access to some user info now that we have an authentication step we can print out that forwarded data. The proxy will pass the decoded access token information to our server through `X-Forwarded-<value>` http headers.

### Potential issues

>Note: When using the Azure Auth provider with nginx and the cookie session store you may find the cookie is too large and doesn’t get passed through correctly. Increasing the proxy_buffer_size in nginx or implementing the redis session storage should resolve this.

See [github.com-radix-example-oauth-proxy](https://github.com/equinor/radix-example-oauth-proxy) for an example using redis for session storage instead of cookies.
